# Пакет `/api/`

## Общая стратегия и назначение

Папка `/api/` представляет собой фундаментальную основу всей архитектуры библиотеки **hioload-ws**, закладывая прочную технологическую платформу для реализации сверх высоконагруженных сетевых решений, в том числе инновационной WebSocket-библиотеки нового поколения. Архитектура этого слоя выстроена в полном соответствии с концепциями **чистой архитектуры** (Clean Architecture), ориентируясь на требования кроссплатформенности, максимальной производительности, гибкости расширения и промышленной надежности.

Цели и задачи модуля `/api/`:

- Предоставление **унифицированных интерфейсов и контрактов** для основных транспортных, сетевых и инфраструктурных компонентов системы;
- Обеспечение максимальной переносимости между современными реализациями Linux (≥6.20) и Windows Server (≥2016);
- Интеграция всех лучших отраслевых практик, включая **DPDK**, RDMA, OS-bypass, zero-copy батчинг и NUMA-aware оптимизации;
- Полная модульность и универсальная тестируемость компонентов;
- Полный **охват функциональных и нефункциональных требований** к решениям категории high-load: минимизация латентности, масштабируемость, поддержка горячих обновлений и live-конфигурирования, расширяемая поддержка метрик, трассировки и дебага.


## Архитектурная спецификация

В основе структуры `/api/` лежат следующие принципы:

- **Zero-copy и Zero-allocation**: Максимально эффективная работа с памятью без лишних аллокаций, поддержка hugepages, прямого маппинга, батчинг без overhead-ов;
- **NUMA-aware**: Все аллокаторы и execution-пулы поддерживают работу в NUMA-системах, предоставляется управление локальностью потоков, буферов и обработчиков;
- **Poll-mode event loops**: Основная обработка сообщений и событий реализована через активные циклы опроса (reactor pattern, DPDK/NAPI-like), минимизируя затрату на прерывания и системные вызовы;
- **Lock-free/Wait-free структуры**: Везде где возможно используются lock-free алгоритмы, минимизируется contention и эффект ложных sharing-ов;
- **Тестируемость и расширяемость**: Каждый интерфейс/контракт проектируется с максимальной мокаемостью, легко покрывается юнит- и property-based тестами;
- **Явная документация (EN)**: Все интерфейсы снабжены подробными комментариями на английском языке для легкости интеграции и промышленной поддержки.


## Содержимое папки `/api/`

Файлы и их предназначение:


| Файл | Назначение |
| :-- | :-- |
| `transport.go` | Интерфейс транспорта данных: zero-copy, NUMA, batching |
| `poll.go` | Интерфейс poll-mode event loop (reactor для массовой обработки) |
| `batching.go` | Дженерик-интерфейс эффективных батчей/групп объектов |
| `buffer.go` | Интерфейсы буферов памяти, уровень пула, NUMA-aware |
| `affinity.go` | Контракты CPU pinning/NUMA-биндинга для потоков, горутин |
| `context.go` | Расширяемый контекст исполнения: типобезопасный key-value store |
| `result.go` | Унификация async-результатов и отмен, контракт result/cancelable |
| `handler.go` | Обработка событий/батчей/данных, extension point для middleware |
| `ring.go` | Lock-free кольцевой буфер, параллелизм между потоками/Goroutine |
| `control.go` | Горячая конфигурация, runtime-метрики, observer pattern |
| `testing.go` | Mock-реализации и вспомогательные тестовые утилиты |
| `scheduler.go` | Абстракция таймера/событийного планировщика |
| `tracer.go` | Интерфейс трассировки (span-based tracing, observability) |
| `debug.go` | Live debug/интроспекция и динамические probes |
| `executor.go` | Многопоточный execution pool/event loop, поддержка динамики |

## Развернутое описание компонентов

### 1. Интерфейс `Transport`

Главный контракт транспортного слоя для отправки/приема массивов байтов (батчинг) с полным учетом zero-copy, NUMA-aware распределения, поддержки SHM/RDMA и возможности динамической смены транспорта во время выполнения (hot swap).

**Основные свойства:**

- Отправка batched/multi-buffer (`Send(buffers [][]byte)`), прямое взаимодействие с пулом памяти (BufferPool)
- Явное описание поддерживаемых возможностей (`TransportFeatures`)
- Минимизация копирований и аллокаций – работа с внешними буферами, hugepages, SHM, mmap
- Многопротокольность (расширение под TCP, UDP, IPC, RDMA)


### 2. Event Loop: `Poller`

Построен по паттернам DPDK и NAPI (poll-mode reactor):

- Явный контроль за обработкой пачек событий – минимизация syscall
- Возможность регистраций/удалений обработчиков на лету, поддержка atomic bulk-операций
- Абстрагирует event loop системного уровня для платформенной переносимости


### 3. Базовые примитивы обработки данных: `Batch`, `Ring`, `Buffer`

- `Batch[T any]`: структурированная работа с групповыми операциями (zero-allocation сплиты, срезы, итерации), транспортабельность между слоями без потерь
- `Ring[T any]`: lock-free кольцевой буфер для высокоскоростной передачи сообщений между потоками/горутинами/NUMA-узлами, поддержка измерения длины и наличия места
- `Buffer`: расширяемый контракт для работы с непрерывными кусками памяти, поддержка slice-операций без выделения, Release/Copy для контроля владения памятью, NUMA-aware pool


### 4. Расширяемый `Context`

- Строгая типизация, методы Set/Get/Delete/Keys
- Контроль области видимости ключей (propagated vs local), возможность TTL/expiration для передачи приоритетных или одноразовых данных между слоями
- Основа для интеграции с tracing/logging


### 5. Исполнительные/планировочные и расширяемые интерфейсы

- `Scheduler` — высокоточный планировщик для timeout/retry/idle-timer сценариев, централизованный контроль за отложенными задачами
- `Executor` — пул рабочих или event loop, runtime-скейлинг, NUMA-aware распределение workers
- `Tracer` — персистентный контракт для интеграции с современными observability-платформами, поддержка span, injection/extraction контекстов
- `Debug` — прямая интеграция с probe/health сервисами и live dump инфраструктурой


### 6. Горячие обновления и контроль: `Control`

- Callback-ориентированный hot-reload, atomic swap конфигураций
- Live-метрики и снэпшоты текущей производительности, поддержка внешних метрик-коллекторов


### 7. Mock/Test Framework

- Mock реализации для всех ключевых интерфейсов (в первую очередь Transport/Buffer/Batch)
- Преднастройка сценариев отказа и измерений performance для property-based тестирования
- Extendable test-helpers под новые стандарты и контракты (все coverage-утилиты должны интегрироваться без модификаций оригинального кода)


## Примеры использования (фрагменты)

### Батчинг буферов

```go
// Пример отправки нескольких сообщений без копирования:
var batch api.Batch[api.Buffer]
for i := 0; i < eventsCount; i++ {
    buffer := bufferPool.Get(size, numaID)
    // ...fill buffer...
    batch = batch.Append(buffer)
}
err := transport.Send(batch.Underlying())
```


### NUMA-aware allocation

```go
// NUMA-aware пул буферов:
buffer := bufferPool.Get(4096, numaPreferred)  // Минимизирует межузловую латентность
```


### CPU Pinning для event loop

```go
aff := affinityManager.New()
aff.Pin(cpuID, numaNode)
// ...event loop runs with binding...
aff.Unpin()
```


### Горячая перезагрузка конфигурации

```go
control.OnReload(func() {
    // Обновить локальные настройки или пересоздать пул воркеров
})
```


## Корневые требования к библиотеке WebSocket

- **Максимальное использование zero-copy и prefetch-стратегий** во всех операциях — websocket messages, control frames;
- **Многопоточность и NUMA-aware thread pool** для логики helm, ping/pong, broadcasting;
- **Высокоэффективная работа через Poller** — каждый воркер обрабатывает свой набор подключений и сообщений в poll-цикле, минимизация взаимодействий через lock-free ring-механизмы;
- **Автоматизированная трассировка, метрики и диагностика** (span injection, debug API);
- **Возможность интеграции с WASM, hook-слоями и индивидуальным event-loop per-core/Numa node**
- **Горячая смена транспорта** (shared memory ↔ RDMA ↔ TCP/UDP) без перезагрузки ядра
