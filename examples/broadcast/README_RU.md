# Пример «Broadcast / Чат-сервер» на базе hioload-ws (без HTTP)

## Общее описание

Данный пример реализует **WebSocket-сервер широковещательной передачи** без использования `net/http`. Все сообщения от клиентов немедленно доставляются всем подключённым участникам.

Ключевые особенности:
- Работает на **низкоуровневом TCP-сокете** через `hioload-ws`
- Использует **батчинг** и **zero-copy** буфера
- **NUMA-aware** память + pinning потоков к сокетам
- **Без goroutine на каждое соединение** — только reactor loop
- Свой **реестр клиентов** для рассылки сообщений
- Реализация **Graceful Shutdown** и отладочных метрик

---

## Основные компоненты

### BroadcastRegistry
Потокобезопасная структура хранения всех активных подключений для рассылки сообщений.

### protocol.WSConnection
Каждое активное WebSocket-соединение представлено этим типом. Подписчик получает кадры и может отправлять ответы.

### BufferPool / Zero-Copy
Используются NUMA-aware пулы буферов (`api.BufferPool`). Весь обмен идёт без дополнительных аллокаций памяти.

### Poller / Reactor
Событийный цикл, обрабатывающий кадры от всех клиентов посредством batched poll. Это обеспечивает масштабируемость до миллионов соединений.

---

## Запуск и сборка

1. Убедитесь, что установлен Go версии 1.23+
```

cd examples/broadcast
go build -o broadcast

```

2. Запустите сервер:
```

./broadcast -addr=":9002" -shards=32 -workers=8 -batch=64 -ring=2048

```

---

## Описание параметров запуска

| Флаг         | Описание                                                                 |
|--------------|--------------------------------------------------------------------------|
| `-addr`      | Адрес для приёма WebSocket-соединений (например, `:9002`)                |
| `-shards`    | Кол-во шард для session manager (по умолчанию 16); масштабируемость       |
| `-workers`   | Количество воркеров, обрабатывающих события (обычно = количеству CPU ядер)|
| `-batch`     | Размер батча для циклов опроса событий (poller)                           |
| `-ring`      | Ёмкость кольцевого буфера между poller и обработчиками                    |
| `-numa`      | NUMA-узел для закрепления буферов и потоков (по умолчанию -1 = авто)      |

---

## Пример работы с wscat

1. В двух разных терминалах запустите:
```

wscat -c ws://localhost:9002

```

2. Отправьте сообщение:
```

Привет, мир!

```

3. Оно будет получено **всеми подключёнными** одновременно.

---

## Отладка и проба статуса

В коде зарегистрирован probe `"active_clients"`:

```

GetControl().RegisterDebugProbe("active_clients", func() any {
return fmt.Sprintf("%d", registry.Size())
})

```

Эта метрика может быть получена через внешний мониторинг (например, Prometheus hook) или в логах.

---

## Завершение работы

- Обработка SIGINT/SIGTERM
- Закрытие слушателя
- Остановка всех poller/executor
- Очистка буферов и клиентов

---

## Технические преимущества

- **Без HTTP** — используется только WebSocket-протокол с zero-copy фреймами
- **Zero-alloc обработка** — минимизация GC и latency
- Поддержка **NUMA**, affinity, batch обработки, DPDK при необходимости
- Производительность уровня миллиона соединений/тысячи сообщений в секунду
- Поддержка Windows и Linux (epoll, IOCP)

---
